Index: trunk/Fatica.Labs.HqlEditor.TestBed/MainForm.cs
===================================================================
--- trunk/Fatica.Labs.HqlEditor.TestBed/MainForm.cs	(revision 34)
+++ trunk/Fatica.Labs.HqlEditor.TestBed/MainForm.cs	(working copy)
@@ -15,7 +15,7 @@
         public MainForm()
         {
             InitializeComponent();
-            hqlEditor1.NHConfigDataProvider = new NHConfigDataProvider(TestHqlIntellisense.Tests.CreateCfg());
+            hqlEditor1.NHConfigDataProvider = new SimpleConfigurationProvider(TestHqlIntellisense.Tests.CreateCfg());
         }
     }
 }
Index: trunk/Fatica.Labs.HqlEditor.TestBed/Properties/Resources.Designer.cs
===================================================================
--- trunk/Fatica.Labs.HqlEditor.TestBed/Properties/Resources.Designer.cs	(revision 34)
+++ trunk/Fatica.Labs.HqlEditor.TestBed/Properties/Resources.Designer.cs	(working copy)
@@ -1,69 +1,61 @@
 ﻿//------------------------------------------------------------------------------
 // <auto-generated>
-//     This code was generated by a tool.
-//     Runtime Version:2.0.50727.3607
+//     Este código fue generado por una herramienta.
+//     Versión del motor en tiempo de ejecución:2.0.50727.4927
 //
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
+//     Los cambios en este archivo podrían causar un comportamiento incorrecto y se perderán si
+//     se vuelve a generar el código.
 // </auto-generated>
 //------------------------------------------------------------------------------
 
-namespace Fatica.Labs.HqlEditor.TestBed.Properties
-{
-
-
+namespace Fatica.Labs.HqlEditor.TestBed.Properties {
+    using System;
+    
+    
     /// <summary>
-    ///   A strongly-typed resource class, for looking up localized strings, etc.
+    ///   Clase de recurso con establecimiento inflexible de tipos, para buscar cadenas traducidas, etc.
     /// </summary>
-    // This class was auto-generated by the StronglyTypedResourceBuilder
-    // class via a tool like ResGen or Visual Studio.
-    // To add or remove a member, edit your .ResX file then rerun ResGen
-    // with the /str option, or rebuild your VS project.
+    // StronglyTypedResourceBuilder generó automáticamente esta clase
+    // a través de una herramienta como ResGen o Visual Studio.
+    // Para agregar o quitar un miembro, edite el archivo .ResX y, a continuación, vuelva a ejecutar ResGen
+    // con la opción /str o vuelva a generar su proyecto de VS.
     [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
     [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
     [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
-    internal class Resources
-    {
-
+    internal class Resources {
+        
         private static global::System.Resources.ResourceManager resourceMan;
-
+        
         private static global::System.Globalization.CultureInfo resourceCulture;
-
+        
         [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
-        internal Resources()
-        {
+        internal Resources() {
         }
-
+        
         /// <summary>
-        ///   Returns the cached ResourceManager instance used by this class.
+        ///   Devuelve la instancia de ResourceManager almacenada en caché utilizada por esta clase.
         /// </summary>
         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
-        internal static global::System.Resources.ResourceManager ResourceManager
-        {
-            get
-            {
-                if ((resourceMan == null))
-                {
+        internal static global::System.Resources.ResourceManager ResourceManager {
+            get {
+                if (object.ReferenceEquals(resourceMan, null)) {
                     global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Fatica.Labs.HqlEditor.TestBed.Properties.Resources", typeof(Resources).Assembly);
                     resourceMan = temp;
                 }
                 return resourceMan;
             }
         }
-
+        
         /// <summary>
-        ///   Overrides the current thread's CurrentUICulture property for all
-        ///   resource lookups using this strongly typed resource class.
+        ///   Reemplaza la propiedad CurrentUICulture del subproceso actual para todas las
+        ///   búsquedas de recursos mediante esta clase de recurso con establecimiento inflexible de tipos.
         /// </summary>
         [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
-        internal static global::System.Globalization.CultureInfo Culture
-        {
-            get
-            {
+        internal static global::System.Globalization.CultureInfo Culture {
+            get {
                 return resourceCulture;
             }
-            set
-            {
+            set {
                 resourceCulture = value;
             }
         }
Index: trunk/Fatica.Labs.HqlEditor/HQLCompletionData.cs
===================================================================
--- trunk/Fatica.Labs.HqlEditor/HQLCompletionData.cs	(revision 34)
+++ trunk/Fatica.Labs.HqlEditor/HQLCompletionData.cs	(working copy)
@@ -19,24 +19,24 @@
 
         public string Description
         {
-            get { return proposal.GetSimpleName(); }
+            get { return proposal.SimpleName; }
         }
 
         public int ImageIndex
         {
             get 
             {
-                switch (proposal.GetCompletionKind())
+                switch (proposal.CompletionKind)
                 {
-                    case HQLCompletionProposal.ALIAS_REF:
+                    case CompletionKind.AliasRef:
                         return 0;
-                    case HQLCompletionProposal.ENTITY_NAME:
+                    case CompletionKind.EntityName:
                         return 1;
-                    case HQLCompletionProposal.FUNCTION:
+                    case CompletionKind.Function:
                         return 2;
-                    case HQLCompletionProposal.KEYWORD:
+                    case CompletionKind.KeyWord:
                         return 3;
-                    case HQLCompletionProposal.PROPERTY:
+                    case CompletionKind.Property:
                         return 4;
                     default: return 5;
                 }
@@ -45,7 +45,7 @@
 
         public bool InsertAction(ICSharpCode.TextEditor.TextArea textArea, char ch)
         {
-            string completion = proposal.GetCompletion();
+            string completion = proposal.Completion;
             //if (DotStart)
             //    completion = string.Concat(".", completion);
             textArea.InsertString(completion);
@@ -61,7 +61,7 @@
         {
             get
             {
-                return proposal.GetSimpleName();
+                return proposal.SimpleName;
             }
             set
             {
@@ -76,7 +76,7 @@
         public int CompareTo(object obj)
         {
             HQLCompletionData rhs = obj as HQLCompletionData;
-            return proposal.GetCompletionKind().CompareTo(rhs.proposal.GetCompletionKind());
+            return proposal.CompletionKind.CompareTo(rhs.proposal.CompletionKind);
         }
 
         #endregion
Index: trunk/Fatica.Labs.HqlEditor/HqlCompletionDataProvider.cs
===================================================================
--- trunk/Fatica.Labs.HqlEditor/HqlCompletionDataProvider.cs	(revision 34)
+++ trunk/Fatica.Labs.HqlEditor/HqlCompletionDataProvider.cs	(working copy)
@@ -27,13 +27,13 @@
 
         #region IHQLCompletionRequestor Members
 
-        public bool accept(HQLCompletionProposal proposal)
+        public bool Accept(HQLCompletionProposal proposal)
         {
             completion.Add(new HQLCompletionData(proposal) { DotStart=DotCompletion });
             return true;
         }
 
-        public void completionFailure(string errorMessage)
+        public void CompletionFailure(string errorMessage)
         {
             
         }
Index: trunk/HqlIntellisense/CompletionHelper.cs
===================================================================
--- trunk/HqlIntellisense/CompletionHelper.cs	(revision 34)
+++ trunk/HqlIntellisense/CompletionHelper.cs	(working copy)
@@ -14,7 +14,7 @@
         {
         }
 
-        public static String getCanonicalPath(List<EntityNameReference> qts, String name)
+        public static string getCanonicalPath(List<EntityNameReference> qts, string name)
         {
             IDictionary<string, string> alias2Type = new Dictionary<string, string>();
 
@@ -25,7 +25,7 @@
             if (qts.Count == 1)
             {
                 EntityNameReference visible = (EntityNameReference)qts[0];
-                String alias = visible.Alias;
+                string alias = visible.Alias;
                 if (name.Equals(alias))
                 {
                     return visible.EntityName;
@@ -39,7 +39,7 @@
         }
 
 
-        private static String getCanonicalPath(HashSet<string> resolved, IDictionary<string, string> alias2Type, String name)
+        private static string getCanonicalPath(HashSet<string> resolved, IDictionary<string, string> alias2Type, string name)
         {
             if (resolved.Contains(name))
             {
@@ -47,7 +47,7 @@
                 return name;
             }
             resolved.Add(name);
-            String type = null;
+            string type = null;
             alias2Type.TryGetValue(name, out type);
 
             if (type != null)
@@ -59,8 +59,8 @@
             {
                 return type != null ? type : name;
             }
-            String baseName = name.Substring(0, idx);
-            String prop = name.Substring(idx + 1);
+            string baseName = name.Substring(0, idx);
+            string prop = name.Substring(idx + 1);
             if (isAliasNown(alias2Type, baseName))
             {
                 return getCanonicalPath(resolved, alias2Type, baseName) + "/" + prop;
@@ -71,7 +71,7 @@
             }
         }
 
-        private static bool isAliasNown(IDictionary<string, string> alias2Type, String alias)
+        private static bool isAliasNown(IDictionary<string, string> alias2Type, string alias)
         {
             if (alias2Type.ContainsKey(alias))
             {
Index: trunk/HqlIntellisense/ConfigurationAbstraction/ConfigurationMapper.cs
===================================================================
--- trunk/HqlIntellisense/ConfigurationAbstraction/ConfigurationMapper.cs	(revision 0)
+++ trunk/HqlIntellisense/ConfigurationAbstraction/ConfigurationMapper.cs	(revision 0)
@@ -0,0 +1,66 @@
+﻿using System.Collections.Generic;
+using System.Linq;
+using NHibernate.Cfg;
+using NHibernate.Mapping;
+
+namespace HqlIntellisense.ConfigurationAbstraction
+{
+	public class ConfigurationMapper
+	{
+		private readonly Configuration configuration;
+
+		public ConfigurationMapper(Configuration configuration)
+		{
+			this.configuration = configuration;
+		}
+
+		public IEnumerable<IPersistentClassInformation> GetClasses()
+		{
+			return configuration.ClassMappings.Select(cm => MapClass(cm)).ToArray();
+		}
+
+		public static IPersistentClassInformation MapClass(PersistentClass cm)
+		{
+			return new PersistentClassInformation
+			       	{
+			       		EntityName = cm.EntityName,
+			       		ClassName = cm.ClassName,
+			       		IdentifierProperty =cm.IdentifierProperty == null ? null : 
+			       		                                                         	new PersistentIdentifierProperty(cm.IdentifierProperty.Name,
+			       		                                                         	                                 MapValue(cm.IdentifierProperty.Value)),
+			       		Properties = MapProperties(cm.PropertyIterator).ToArray()
+			       	};
+		}
+
+		public static IEnumerable<IPersistentProperty> MapProperties(IEnumerable<Property> propertyIterator)
+		{
+			return propertyIterator.Select(p => new PersistentProperty(p.Name, MapValue(p.Value))).OfType<IPersistentProperty>();
+		}
+
+		public static IPersistentValue MapValue(IValue value)
+		{
+			var component = value as Component;
+			if(component != null)
+			{
+				return new PersistentComponent(MapProperties(component.PropertyIterator));
+			}
+			var collection = value as Collection;
+			if(collection != null)
+			{
+				return new PersistentCollection(MapValue(collection.Element));
+			}
+			var toOne = value as ToOne;
+			if(toOne != null)
+			{
+				return new PersistentToOne(toOne.ReferencedEntityName);
+			}
+
+			var oneToMany = value as OneToMany;
+			if(oneToMany != null)
+			{
+				return new PersistentOneToMany(oneToMany.ReferencedEntityName);
+			}
+			return null;
+		}
+	}
+}
\ No newline at end of file
Index: trunk/HqlIntellisense/ConfigurationAbstraction/Interfaces.cs
===================================================================
--- trunk/HqlIntellisense/ConfigurationAbstraction/Interfaces.cs	(revision 0)
+++ trunk/HqlIntellisense/ConfigurationAbstraction/Interfaces.cs	(revision 0)
@@ -0,0 +1,49 @@
+using System.Collections.Generic;
+
+namespace HqlIntellisense.ConfigurationAbstraction
+{
+
+	public interface IPersistentClassInformation
+	{
+		IEnumerable<IPersistentProperty> Properties { get; }
+		string EntityName { get; }
+		IPersistentIdentifier IdentifierProperty { get; set; }
+		string ClassName { get; }
+		IPersistentProperty GetProperty(string attribute);
+	}
+
+	public interface IPersistentIdentifier
+	{
+		string Name { get; }
+		IPersistentValue Value { get; }
+	}
+
+	public interface IPersistentValue
+	{
+	}
+
+	public interface IPersistentProperty
+	{
+		string Name { get; }
+		IPersistentValue Value { get; }
+	}
+
+	public interface IPersistentComponent : IPersistentValue
+	{
+		IEnumerable<IPersistentProperty> Properties { get; }
+	}
+
+	public interface IPersistentCollection : IPersistentValue
+	{
+		IPersistentValue Element { get; }
+	}
+	public interface IPersistentToOne : IPersistentValue
+	{
+		string ReferencedEntityName { get; }
+	}
+
+	public interface IPersistentOneToMany : IPersistentValue
+	{
+		string ReferencedEntityName { get; }
+	}
+}
\ No newline at end of file
Index: trunk/HqlIntellisense/ConfigurationAbstraction/PersistentClassInformation.cs
===================================================================
--- trunk/HqlIntellisense/ConfigurationAbstraction/PersistentClassInformation.cs	(revision 0)
+++ trunk/HqlIntellisense/ConfigurationAbstraction/PersistentClassInformation.cs	(revision 0)
@@ -0,0 +1,27 @@
+using System;
+using System.Collections.Generic;
+using System.Linq;
+
+namespace HqlIntellisense.ConfigurationAbstraction
+{
+	[Serializable]
+	public class PersistentClassInformation : IPersistentClassInformation
+	{
+		#region IPersistentClassInformation Members
+
+		public IEnumerable<IPersistentProperty> Properties { get; set; }
+
+		public string EntityName { get; set; }
+
+		public IPersistentIdentifier IdentifierProperty { get; set; }
+
+		public string ClassName { get; set; }
+
+		public IPersistentProperty GetProperty(string attribute)
+		{
+			return Properties.FirstOrDefault(p => p.Name == attribute);
+		}
+
+		#endregion
+	}
+}
\ No newline at end of file
Index: trunk/HqlIntellisense/ConfigurationAbstraction/PersistentCollection.cs
===================================================================
--- trunk/HqlIntellisense/ConfigurationAbstraction/PersistentCollection.cs	(revision 0)
+++ trunk/HqlIntellisense/ConfigurationAbstraction/PersistentCollection.cs	(revision 0)
@@ -0,0 +1,18 @@
+﻿using System;
+
+namespace HqlIntellisense.ConfigurationAbstraction
+{
+	[Serializable]
+	public class PersistentCollection : IPersistentCollection
+	{
+		public PersistentCollection(IPersistentValue element)
+		{
+			Element = element;
+		}
+
+		public IPersistentValue Element
+		{
+			get; private set;
+		}
+	}
+}
\ No newline at end of file
Index: trunk/HqlIntellisense/ConfigurationAbstraction/PersistentComponent.cs
===================================================================
--- trunk/HqlIntellisense/ConfigurationAbstraction/PersistentComponent.cs	(revision 0)
+++ trunk/HqlIntellisense/ConfigurationAbstraction/PersistentComponent.cs	(revision 0)
@@ -0,0 +1,19 @@
+﻿using System;
+using System.Collections.Generic;
+
+namespace HqlIntellisense.ConfigurationAbstraction
+{
+	[Serializable]
+	public class PersistentComponent : IPersistentComponent
+	{
+		public PersistentComponent(IEnumerable<IPersistentProperty> properties)
+		{
+			Properties = properties;
+		}
+
+		public IEnumerable<IPersistentProperty> Properties
+		{
+			get; private set;
+		}
+	}
+}
\ No newline at end of file
Index: trunk/HqlIntellisense/ConfigurationAbstraction/PersistentIdentifierProperty.cs
===================================================================
--- trunk/HqlIntellisense/ConfigurationAbstraction/PersistentIdentifierProperty.cs	(revision 0)
+++ trunk/HqlIntellisense/ConfigurationAbstraction/PersistentIdentifierProperty.cs	(revision 0)
@@ -0,0 +1,17 @@
+using System;
+
+namespace HqlIntellisense.ConfigurationAbstraction
+{
+	[Serializable]
+	public class PersistentIdentifierProperty : IPersistentIdentifier
+	{
+		public PersistentIdentifierProperty(string name, IPersistentValue value)
+		{
+			Name = name;
+			Value = value;
+		}
+
+		public string Name { get; private set; }
+		public IPersistentValue Value { get; private set; }
+	}
+}
\ No newline at end of file
Index: trunk/HqlIntellisense/ConfigurationAbstraction/PersistentOneToMany.cs
===================================================================
--- trunk/HqlIntellisense/ConfigurationAbstraction/PersistentOneToMany.cs	(revision 0)
+++ trunk/HqlIntellisense/ConfigurationAbstraction/PersistentOneToMany.cs	(revision 0)
@@ -0,0 +1,18 @@
+﻿using System;
+
+namespace HqlIntellisense.ConfigurationAbstraction
+{
+	[Serializable]
+	public class PersistentOneToMany : IPersistentOneToMany
+	{
+		public PersistentOneToMany(string referencedEntityName)
+		{
+			ReferencedEntityName = referencedEntityName;
+		}
+
+		public string ReferencedEntityName
+		{
+			get; private set;
+		}
+	}
+}
\ No newline at end of file
Index: trunk/HqlIntellisense/ConfigurationAbstraction/PersistentProperty.cs
===================================================================
--- trunk/HqlIntellisense/ConfigurationAbstraction/PersistentProperty.cs	(revision 0)
+++ trunk/HqlIntellisense/ConfigurationAbstraction/PersistentProperty.cs	(revision 0)
@@ -0,0 +1,24 @@
+﻿using System;
+
+namespace HqlIntellisense.ConfigurationAbstraction
+{
+	[Serializable]
+	public class PersistentProperty : IPersistentProperty
+	{
+		public PersistentProperty(string name, IPersistentValue value)
+		{
+			Name = name;
+			Value = value;
+		}
+
+		public string Name
+		{
+			get; private set;
+		}
+
+		public IPersistentValue Value
+		{
+			get; private set;
+		}
+	}
+}
\ No newline at end of file
Index: trunk/HqlIntellisense/ConfigurationAbstraction/PersistentToOne.cs
===================================================================
--- trunk/HqlIntellisense/ConfigurationAbstraction/PersistentToOne.cs	(revision 0)
+++ trunk/HqlIntellisense/ConfigurationAbstraction/PersistentToOne.cs	(revision 0)
@@ -0,0 +1,18 @@
+﻿using System;
+
+namespace HqlIntellisense.ConfigurationAbstraction
+{
+	[Serializable]
+	public class PersistentToOne : IPersistentToOne
+	{
+		public PersistentToOne(string referencedEntityName)
+		{
+			ReferencedEntityName = referencedEntityName;
+		}
+
+		public string ReferencedEntityName
+		{
+			get; private set;
+		}
+	}
+}
\ No newline at end of file
Index: trunk/HqlIntellisense/ConfigurationCompletion.cs
===================================================================
--- trunk/HqlIntellisense/ConfigurationCompletion.cs	(revision 34)
+++ trunk/HqlIntellisense/ConfigurationCompletion.cs	(working copy)
@@ -2,423 +2,408 @@
 // felice@felicepollano.com
 // www.felicepollano.com
 
-using NHibernate.Cfg;
 using System;
-using NHibernate.Mapping;
-using NHibernate;
-using System.Diagnostics;
 using System.Collections.Generic;
 using System.Linq;
+using HqlIntellisense.ConfigurationAbstraction;
+using NHibernate;
+using NHibernate.Mapping;
+using Array = System.Array;
+
 namespace HqlIntellisense
 {
-    class ConfigurationCompletion
-    {
+	internal class ConfigurationCompletion
+	{
+		private readonly IConfigurationDataProvider cfg;
 
-        private IConfigurationDataProvider cfg;
+		public ConfigurationCompletion(IConfigurationDataProvider cfg)
+		{
+			this.cfg = cfg;
+		}
 
-        public ConfigurationCompletion(IConfigurationDataProvider cfg)
-        {
-		    this.cfg = cfg;
-    		
-	    }
+		public void GetMatchingImports(string prefix, IHQLCompletionRequestor collector)
+		{
+			GetMatchingImports(prefix, prefix.Length, collector);
+		}
 
-	    public void GetMatchingImports(String prefix , IHQLCompletionRequestor collector)
-        {
-		    GetMatchingImports( prefix, prefix.Length , collector );
-	    }
-    	
-	    public void GetMatchingImports(String prefix, int cursorPosition, IHQLCompletionRequestor collector) 
-        {
-            if (null != cfg.Imports)
-            {
-                foreach (var entry in cfg.Imports)
-                {
-                    String entityImport = (String)entry.Key;
-                    String entityName = (String)entry.Value;
-                    if (entityImport.ToLower().StartsWith(prefix.ToLower()))
-                    {
-                        HQLCompletionProposal proposal = CreateStartWithCompletionProposal(prefix, cursorPosition, HQLCompletionProposal.ENTITY_NAME, entityImport);
-                        proposal.ShortEntityName = entityImport;
-                        proposal.EntityName = entityName;
-                        collector.accept(proposal);
-                    }
-                }
-            }
-	    }
-    	
-	    public void GetMatchingKeywords(String prefix, int cursorPosition, IHQLCompletionRequestor collector) 
-        {
-		    FindMatchingWords( cursorPosition, prefix, HQLAnalyzer.GetHQLKeywords(), HQLCompletionProposal.KEYWORD, collector);
-	    }
+		public void GetMatchingImports(string prefix, int cursorPosition, IHQLCompletionRequestor collector)
+		{
+			if (null != cfg.Imports)
+			{
+				foreach (var entry in cfg.Imports)
+				{
+					string entityImport = entry.Key;
+					string entityName = entry.Value;
+					if (entityImport.ToLower().StartsWith(prefix.ToLower()))
+					{
+						HQLCompletionProposal proposal = CreateStartWithCompletionProposal(prefix, cursorPosition,
+						                                                                   CompletionKind.EntityName, entityImport);
+						proposal.ShortEntityName = entityImport;
+						proposal.EntityName = entityName;
+						collector.Accept(proposal);
+					}
+				}
+			}
+		}
 
-	    public void GetMatchingFunctions(String prefix, int cursorPosition, IHQLCompletionRequestor collector) 
-        {
-		    FindMatchingWords( cursorPosition, prefix, HQLAnalyzer.GetHQLFunctionNames(), HQLCompletionProposal.FUNCTION, collector);
-	    }
-    	
-	    public void GetMatchingProperties(String path, String prefix, IHQLCompletionRequestor hcc)
-        {
-		    GetMatchingProperties( path, prefix, prefix.Length, hcc );
-	    }
-    	
-	    public void GetMatchingProperties(String path, String prefix, int cursorPosition, IHQLCompletionRequestor hcc)
-        {
-		    int idx = path.IndexOf('/');
-            if (idx == -1) 
-            { // root name
-                PersistentClass cmd = GetPersistentClass(path);
-                if (cmd == null) 
-                {
-                    return;
-                }
-                AddPropertiesToList(cmd, prefix, cursorPosition, hcc);            
-            } 
-            else
-            {
-                String baseEntityName = path.Substring(0, idx);
-                String propertyPath = path.Substring(idx + 1);
-                IValue value = GetNextAttributeType(baseEntityName, propertyPath);
-                if (value == null) {
-                    return;
-                }
-                
-                // Go to the next property (get the y of x/y/z when root is x)
-                idx = propertyPath.IndexOf('/');
-                if (idx == -1) {
-                    path = "";
-                } else {
-                    path = propertyPath.Substring(idx + 1);
-                }
-                if (path.Length == 0)
-                {
-                    // No properties left
-                    if (value is Component) 
-                    {
-                        AddPropertiesToList((Component) value, prefix, cursorPosition, hcc);
-                    } 
-                    else if (value is Collection && ((Collection)value).Element is Component)
-                    {
-                	    AddPropertiesToList((Component) ((Collection)value).Element, prefix, cursorPosition, hcc);
-                    } else
-                    {
-                	     AddPropertiesToList(GetPersistentClass( GetReferencedEntityName( value ) ), prefix, cursorPosition, hcc);
-                    }
-                } else 
-                {
-                    // Nested properties
-                    if (value is Component)
-                    {
-                        // We need to find the first non-component type 
-                        while (value is Component && path.Length > 0) 
-                        {
-                            value = GetNextAttributeType((Component) value, path);
-                            if (value != null)
-                            {
-                                // Consume part of the canonical path
-                                idx = path.IndexOf('/');
-                                if (idx != -1) 
-                                {
-                                    path = path.Substring(idx + 1);
-                                } else 
-                                {
-                                    path = "";
-                                }
-                            }
-                        }
-                        if (value is Component)
-                        {
-                            AddPropertiesToList((Component) value, prefix, cursorPosition, hcc);
-                        } else if (value != null) 
-                        {
-                            if (path.Length > 0)
-                            {
-                                path = GetReferencedEntityName( value ) + "/" + path;
-                            } else
-                            {
-                                path = GetReferencedEntityName( value );
-                            }
-                            GetMatchingProperties( path, prefix, cursorPosition, hcc );
-                        }
-                    } else 
-                    {
-                        // Just call the method recursively to add our new type
-                        GetMatchingProperties(GetReferencedEntityName( value ) + "/" + path, prefix, cursorPosition, hcc);
-                    }
-                }
-            }
-	    }
+		public void GetMatchingKeywords(string prefix, int cursorPosition, IHQLCompletionRequestor collector)
+		{
+			FindMatchingWords(cursorPosition, prefix, HQLAnalyzer.GetHQLKeywords(), CompletionKind.KeyWord, collector);
+		}
 
-	    private String GetReferencedEntityName(IValue value)
-        {
-		    if(value is ToOne) 
-            {
-			    return ((ToOne)value).ReferencedEntityName;
-		    }
-		    if ( value is Collection )
-            {
-			    Collection collection = ((Collection)value);
-			    IValue element = collection.Element;
-			    String elementType = GetReferencedEntityName( element );
-                /*
+		public void GetMatchingFunctions(string prefix, int cursorPosition, IHQLCompletionRequestor collector)
+		{
+			FindMatchingWords(cursorPosition, prefix, HQLAnalyzer.GetHQLFunctionNames(), CompletionKind.Function, collector);
+		}
+
+		public void GetMatchingProperties(string path, string prefix, IHQLCompletionRequestor hcc)
+		{
+			GetMatchingProperties(path, prefix, prefix.Length, hcc);
+		}
+
+		public void GetMatchingProperties(string path, string prefix, int cursorPosition, IHQLCompletionRequestor hcc)
+		{
+			int idx = path.IndexOf('/');
+			if (idx == -1)
+			{
+				// root name
+				IPersistentClassInformation cmd = GetPersistentClass(path);
+				if (cmd == null)
+				{
+					return;
+				}
+				AddPropertiesToList(cmd, prefix, cursorPosition, hcc);
+			}
+			else
+			{
+				string baseEntityName = path.Substring(0, idx);
+				string propertyPath = path.Substring(idx + 1);
+				IPersistentValue value = GetNextAttributeType(baseEntityName, propertyPath);
+				if (value == null)
+				{
+					return;
+				}
+
+				// Go to the next property (get the y of x/y/z when root is x)
+				idx = propertyPath.IndexOf('/');
+				path = idx == -1 ? "" : propertyPath.Substring(idx + 1);
+				if (path.Length == 0)
+				{
+					// No properties left
+					if (value is IPersistentComponent)
+					{
+						AddPropertiesToList((IPersistentComponent) value, prefix, cursorPosition, hcc);
+					}
+					else if (value is IPersistentCollection && ((IPersistentCollection) value).Element is IPersistentComponent)
+					{
+						AddPropertiesToList((IPersistentComponent) ((Collection) value).Element, prefix, cursorPosition, hcc);
+					}
+					else
+					{
+						AddPropertiesToList(GetPersistentClass(GetReferencedEntityName(value)), prefix, cursorPosition, hcc);
+					}
+				}
+				else
+				{
+					// Nested properties
+					if (value is Component)
+					{
+						// We need to find the first non-component type 
+						while (value is Component && path.Length > 0)
+						{
+							value = GetNextAttributeType((IPersistentComponent) value, path);
+							if (value != null)
+							{
+								// Consume part of the canonical path
+								idx = path.IndexOf('/');
+								path = idx != -1 ? path.Substring(idx + 1) : "";
+							}
+						}
+						if (value is Component)
+						{
+							AddPropertiesToList((IPersistentComponent) value, prefix, cursorPosition, hcc);
+						}
+						else if (value != null)
+						{
+							if (path.Length > 0)
+							{
+								path = GetReferencedEntityName(value) + "/" + path;
+							}
+							else
+							{
+								path = GetReferencedEntityName(value);
+							}
+							GetMatchingProperties(path, prefix, cursorPosition, hcc);
+						}
+					}
+					else
+					{
+						// Just call the method recursively to add our new type
+						GetMatchingProperties(GetReferencedEntityName(value) + "/" + path, prefix, cursorPosition, hcc);
+					}
+				}
+			}
+		}
+
+		private static string GetReferencedEntityName(IPersistentValue value)
+		{
+			var persistentToOne = value as IPersistentToOne;
+			if (persistentToOne != null)
+			{
+				return persistentToOne.ReferencedEntityName;
+			}
+			var persistentCollection = value as IPersistentCollection;
+			if (persistentCollection != null)
+			{
+				IPersistentCollection collection = persistentCollection;
+				IPersistentValue element = collection.Element;
+				string elementType = GetReferencedEntityName(element);
+				/*
 			    if(collection.isIndexed()) {*/
-				    //TODO..list/map
-				    /*IndexedCollection idxCol = (IndexedCollection) collection;
+				//TODO..list/map
+				/*IndexedCollection idxCol = (IndexedCollection) collection;
 				    if(!idxCol.isList()) {
 					    Value idxElement = idxCol.getIndex();
-					    String indexType = getReferencedEntityName( value );
+					    string indexType = getReferencedEntityName( value );
 					    genericDecl = indexType + "," + elementType;
 				    }*/
-			    /*} */			
-			    return elementType;
-		    }
-    		
-		    if(value is OneToMany)
-            {
-			    return ((OneToMany)value).ReferencedEntityName;
-		    }
-    		
-		    return null;
-	    }
+				/*} */
+				return elementType;
+			}
 
-	    private void AddPropertiesToList(PersistentClass cmd, String prefix, int cursorPosition, IHQLCompletionRequestor hcc) 
-        {
-		    if (cmd == null)
-            {
-                return;
-            }
-            if (prefix == null) 
-            {
-                prefix = "";
-            }
-            foreach (var p in cmd.PropertyIterator)
-            {
-                String candidate = p.Name;
-                if (prefix.Length == 0 || candidate.ToLower().StartsWith(prefix.ToLower()))
-                {
-                    HQLCompletionProposal proposal = CreateStartWithCompletionProposal(prefix, cursorPosition, HQLCompletionProposal.PROPERTY, candidate);
-                    proposal.EntityName = cmd.EntityName;
-                    proposal.Property = p;
-                    proposal.PropertyName = candidate;
-                    hcc.accept(proposal);
-                }
-            }
-            /*
+			var oneToMany = value as IPersistentOneToMany;
+			if (oneToMany != null)
+			{
+				return oneToMany.ReferencedEntityName;
+			}
+
+			return null;
+		}
+
+		private static void AddPropertiesToList(IPersistentClassInformation cmd, string prefix, int cursorPosition,
+		                                        IHQLCompletionRequestor hcc)
+		{
+			if (cmd == null)
+			{
+				return;
+			}
+			if (prefix == null)
+			{
+				prefix = "";
+			}
+			foreach (IPersistentProperty p in cmd.Properties)
+			{
+				string candidate = p.Name;
+				if (prefix.Length == 0 || candidate.ToLower().StartsWith(prefix.ToLower()))
+				{
+					HQLCompletionProposal proposal = CreateStartWithCompletionProposal(prefix, cursorPosition, CompletionKind.Property,
+					                                                                   candidate);
+					proposal.EntityName = cmd.EntityName;
+					proposal.Property = p;
+					proposal.PropertyName = candidate;
+					hcc.Accept(proposal);
+				}
+			}
+			/*
             EntityPOJOClass pc = new EntityPOJOClass(cmd, new Cfg2JavaTool()); // TODO: we should extract the needed functionallity from this hbm2java class.
             
             Iterator allPropertiesIterator = pc.getAllPropertiesIterator();
             while ( allPropertiesIterator.hasNext() ) {
 			    Property property = (Property) allPropertiesIterator.next();
-			    String candidate = property.getName();
+			    string candidate = property.getName();
 		        if (prefix.length() == 0 || candidate.toLowerCase().startsWith(prefix.toLowerCase())) {
-		    	    HQLCompletionProposal proposal = createStartWithCompletionProposal( prefix, cursorPosition, HQLCompletionProposal.PROPERTY, candidate );
+		    	    HQLCompletionProposal proposal = createStartWithCompletionProposal( prefix, cursorPosition, CompletionKind.Property, candidate );
 		    	    proposal.setEntityName( cmd.getEntityName() );
 		    	    proposal.setProperty( property );
 		    	    proposal.setPropertyName( candidate );		    	
 				    hcc.accept( proposal);		    	                
                 }
-            }*/       	
-	    }
+            }*/
+		}
 
-	    private HQLCompletionProposal CreateStartWithCompletionProposal(String prefix, int cursorPosition, int kind, String candidate) 
-        {
-		    HQLCompletionProposal proposal = new HQLCompletionProposal(kind, cursorPosition);
-		    if(candidate.StartsWith(prefix)) 
-            {
-			    proposal.SetCompletion( candidate.Substring(prefix.Length) );
-			    proposal.SetSimpleName( candidate );
-			    proposal.SetReplaceStart( cursorPosition );	
-			    proposal.SetReplaceEnd( cursorPosition );
-		    } else 
-            {
-			    proposal.SetCompletion( candidate );
-			    proposal.SetSimpleName( candidate );
-			    proposal.SetReplaceStart( cursorPosition  - prefix.Length );// replace prefix	
-			    proposal.SetReplaceEnd( cursorPosition ); 	
-		    }
-		    return proposal;
-	    }
+		private static HQLCompletionProposal CreateStartWithCompletionProposal(string prefix, int cursorPosition,
+		                                                                       CompletionKind kind, string candidate)
+		{
+			var proposal = new HQLCompletionProposal(kind, cursorPosition)
+			               	{
+			               		SimpleName = candidate,
+			               		ReplaceEnd = cursorPosition
+			               	};
 
-	    /** returns PersistentClass for path. Can be null if path is an imported non-mapped class */
-	    private PersistentClass GetPersistentClass(String path) 
-        {
-		    if(path==null) return null;
-            String entityName = null;
-            cfg.Imports.TryGetValue(path, out entityName);
-            
-		    if(entityName==null) 
-            {
-			    return cfg.GetClassMapping( path ); // annotationconfiguration does not put full imports into imports.
-		    } else
-            {
-                //Type t = Type.GetType(entityName); // applied patch from socchetti
-                //if (t != null)
-                //    return cfg.GetClassMapping(t);
-                //else
-                    return cfg.GetClassMapping(entityName);
-		    }	
-	    }
+			if (candidate.StartsWith(prefix))
+			{
+				proposal.Completion = candidate.Substring(prefix.Length);
+				proposal.ReplaceStart = cursorPosition;
+			}
+			else
+			{
+				proposal.Completion = candidate;
+				proposal.ReplaceStart = cursorPosition - prefix.Length; // replace prefix	
+			}
+			return proposal;
+		}
 
-	    public String GetCanonicalPath(List<EntityNameReference> qts, String name)
-        {
-		    IDictionary<string,string> alias2Type = new Dictionary<string,string>();
-            foreach( var qt in qts ) 
-            {
-                alias2Type[qt.Alias] = qt.EntityName;
-            }
-            if (qts.Count == 1)
-            { 
-                EntityNameReference visible = (EntityNameReference) qts[0];
-                String alias = visible.Alias;
-                if (name.Equals(alias))
-                {
-                    return visible.EntityName;
-                } 
-                else if (alias == null || alias.Length == 0 || alias.Equals(visible.EntityName)) 
-                {
-                    return visible.EntityName + "/" + name;
-                }
-            }
-            return GetCanonicalPath(new HashSet<string>(), alias2Type, name);		
-	    }
-    	
-	    private String GetCanonicalPath(HashSet<string> resolved, IDictionary<string,string> alias2Type, String name) 
-        {
-            if (resolved.Contains(name))
-            {
-                // To prevent a stack overflow
-                return name;
-            }
-            resolved.Add(name);
-            String type = null;
-            alias2Type.TryGetValue(name, out type);
-            
-            if (type != null)
-            {
-                return name.Equals(type) ? name : GetCanonicalPath(resolved, alias2Type, type);
-            }
-            int idx = name.LastIndexOf('.');
-            if (idx == -1) {
-                return type != null ? type : name;
-            }
-            String baseName = name.Substring(0, idx);
-            String prop = name.Substring(idx + 1);
-            if (IsAliasKnown(alias2Type, baseName))
-            {
-                return GetCanonicalPath(resolved, alias2Type, baseName) + "/" + prop;
-            } else 
-            {
-                return name;
-            }
-        }
-    	
-	    private static bool IsAliasKnown(IDictionary<string,string> alias2Type, String alias)
-        {
-            if (alias2Type.ContainsKey(alias))
-            {
-                return true;
-            }
-            int idx = alias.LastIndexOf('.');
-            if (idx == -1) 
-            {
-                return false;
-            }
-            return IsAliasKnown(alias2Type, alias.Substring(0, idx));
-        }
-        
-	    private IValue GetNextAttributeType(String type, String attributePath)
-        {
-            PersistentClass cmd = GetPersistentClass( type );
-            if (cmd == null) 
-            {
-                return null;
-            }
-            String attribute;
-            int idx = attributePath.IndexOf('/');
-            if (idx == -1) 
-            {
-                attribute = attributePath;
-            } else 
-            {
-                attribute = attributePath.Substring(0, idx);
-            }
-            
-            String idName = cmd.IdentifierProperty==null?null:cmd.IdentifierProperty.Name;
-            if (attribute.Equals(idName)) 
-            {
-                return cmd.IdentifierProperty.Value;
-            }
-            try 
-            {
-        	    Property property = cmd.GetProperty( attribute );
-        	    return property==null?null:property.Value;
-            } catch (HibernateException) 
-            {
-        	    return null;
-            }
-                    
-        }
+		/** returns PersistentClass for path. Can be null if path is an imported non-mapped class */
 
-	    private IValue GetNextAttributeType(Component t, String attributeName)
-        {
-            int idx = attributeName.IndexOf('/');
-            if (idx != -1)
-            {
-                attributeName = attributeName.Substring(0, idx);
-            }
-            var names = t.PropertyIterator;
-           
-            foreach( Property element in names )
-            {
-			    String name = element.Name;
-			    if (attributeName.Equals(name)) {
-                    return element.Value;
-                }
-            }
-            return null;
-        }
-    	
-	    void AddPropertiesToList(Component t, String prefix, int cursorPosition, IHQLCompletionRequestor hcc)
-        {
-            if (t == null)
-            {
-                return;
-            }
-            var props = t.PropertyIterator;
-            foreach( Property element in props )
-            {
-			    String candidate = element.Name;
-			    if (candidate.ToLower().StartsWith(prefix.ToLower()))
-                {
-				    HQLCompletionProposal proposal = CreateStartWithCompletionProposal( prefix, cursorPosition, HQLCompletionProposal.PROPERTY, candidate );
-				    //proposal.setEntityName( cmd.getEntityName() ); ...we don't know here..TODO: pass in the "path"
-		    	    proposal.PropertyName = candidate ;
-		    	    proposal.Property =element;
-				    hcc.accept( proposal);				               
-                }
-            }
-        }
-    	
-	    private void FindMatchingWords(int cursorPosition, String prefix, String[] words, int kind, IHQLCompletionRequestor hcc) 
-        {
-            int i = System.Array.BinarySearch(words, prefix.ToLower());
-		    if(i<0) 
-            {
-			    i = Math.Abs(i+1);
-		    }
-    		
-		    for (int cnt = i; cnt < words.Length; cnt++) 
-            {
-			    String word = words[cnt];
-			    if(word.ToLower().StartsWith(prefix.ToLower())) 
-                {
-				    HQLCompletionProposal proposal = CreateStartWithCompletionProposal( prefix, cursorPosition, kind, word );
-				    hcc.accept( proposal);				
-			    } else 
-                {
-				    break;
-			    }
-		    }
-	    }
+		private IPersistentClassInformation GetPersistentClass(string path)
+		{
+			if (path == null) return null;
+			string entityName;
+			cfg.Imports.TryGetValue(path, out entityName);
 
-    }
+			return cfg.GetClassMapping(entityName ?? path);
+			//Type t = Type.GetType(entityName); // applied patch from socchetti
+			//if (t != null)
+			//    return cfg.GetClassMapping(t);
+			//else
+		}
+
+		public string GetCanonicalPath(List<EntityNameReference> qts, string name)
+		{
+			IDictionary<string, string> alias2Type = new Dictionary<string, string>();
+			foreach (EntityNameReference qt in qts)
+			{
+				alias2Type[qt.Alias] = qt.EntityName;
+			}
+			if (qts.Count == 1)
+			{
+				EntityNameReference visible = qts[0];
+				string alias = visible.Alias;
+				if (name.Equals(alias))
+				{
+					return visible.EntityName;
+				}
+				if (string.IsNullOrEmpty(alias) || alias.Equals(visible.EntityName))
+				{
+					return visible.EntityName + "/" + name;
+				}
+			}
+			return GetCanonicalPath(new HashSet<string>(), alias2Type, name);
+		}
+
+		private static string GetCanonicalPath(HashSet<string> resolved, IDictionary<string, string> alias2Type, string name)
+		{
+			if (resolved.Contains(name))
+			{
+				// To prevent a stack overflow
+				return name;
+			}
+			resolved.Add(name);
+			string type;
+			alias2Type.TryGetValue(name, out type);
+
+			if (type != null)
+			{
+				return name.Equals(type) ? name : GetCanonicalPath(resolved, alias2Type, type);
+			}
+			int idx = name.LastIndexOf('.');
+			if (idx == -1)
+			{
+				return name;
+			}
+			string baseName = name.Substring(0, idx);
+			string prop = name.Substring(idx + 1);
+			return IsAliasKnown(alias2Type, baseName)
+			       	? GetCanonicalPath(resolved, alias2Type, baseName) + "/" + prop
+			       	: name;
+		}
+
+		private static bool IsAliasKnown(IDictionary<string, string> alias2Type, string alias)
+		{
+			if (alias2Type.ContainsKey(alias))
+			{
+				return true;
+			}
+			int idx = alias.LastIndexOf('.');
+			return idx != -1 && IsAliasKnown(alias2Type, alias.Substring(0, idx));
+		}
+
+		private IPersistentValue GetNextAttributeType(string type, string attributePath)
+		{
+			IPersistentClassInformation cmd = GetPersistentClass(type);
+			if (cmd == null)
+			{
+				return null;
+			}
+			int idx = attributePath.IndexOf('/');
+			string attribute = idx == -1 ? attributePath : attributePath.Substring(0, idx);
+
+			string idName = cmd.IdentifierProperty == null ? null : cmd.IdentifierProperty.Name;
+			if (attribute.Equals(idName))
+			{
+				if (cmd.IdentifierProperty != null) return cmd.IdentifierProperty.Value;
+			}
+			try
+			{
+				IPersistentProperty property = cmd.GetProperty(attribute);
+				return property == null ? null : property.Value;
+			}
+			catch (HibernateException)
+			{
+				return null;
+			}
+		}
+
+		private static IPersistentValue GetNextAttributeType(IPersistentComponent t, string attributeName)
+		{
+			int idx = attributeName.IndexOf('/');
+			if (idx != -1)
+			{
+				attributeName = attributeName.Substring(0, idx);
+			}
+			IEnumerable<IPersistentProperty> names = t.Properties;
+
+			return (from element in names
+			        let name = element.Name
+			        where attributeName.Equals(name)
+			        select element.Value).FirstOrDefault();
+		}
+
+		private static void AddPropertiesToList(IPersistentComponent t, string prefix, int cursorPosition,
+		                                        IHQLCompletionRequestor hcc)
+		{
+			if (t == null)
+			{
+				return;
+			}
+			IEnumerable<IPersistentProperty> props = t.Properties;
+			foreach (IPersistentProperty element in props)
+			{
+				string candidate = element.Name;
+				if (candidate.ToLower().StartsWith(prefix.ToLower()))
+				{
+					HQLCompletionProposal proposal = CreateStartWithCompletionProposal(prefix, cursorPosition, CompletionKind.Property,
+					                                                                   candidate);
+					//proposal.setEntityName( cmd.getEntityName() ); ...we don't know here..TODO: pass in the "path"
+					proposal.PropertyName = candidate;
+					proposal.Property = element;
+					hcc.Accept(proposal);
+				}
+			}
+		}
+
+		private static void FindMatchingWords(int cursorPosition, string prefix, string[] words, CompletionKind kind,
+		                                      IHQLCompletionRequestor hcc)
+		{
+			int i = Array.BinarySearch(words, prefix.ToLower());
+			if (i < 0)
+			{
+				i = Math.Abs(i + 1);
+			}
+
+			for (int cnt = i; cnt < words.Length; cnt++)
+			{
+				string word = words[cnt];
+				if (word.ToLower().StartsWith(prefix.ToLower()))
+				{
+					HQLCompletionProposal proposal = CreateStartWithCompletionProposal(prefix, cursorPosition, kind, word);
+					hcc.Accept(proposal);
+				}
+				else
+				{
+					break;
+				}
+			}
+		}
+	}
 }
\ No newline at end of file
Index: trunk/HqlIntellisense/EntityNameReference.cs
===================================================================
--- trunk/HqlIntellisense/EntityNameReference.cs	(revision 34)
+++ trunk/HqlIntellisense/EntityNameReference.cs	(working copy)
@@ -8,11 +8,11 @@
     public class EntityNameReference
     {
 
-        private String alias;
+        private string alias;
 
-        private String entityName;
+        private string entityName;
 
-        public EntityNameReference(String type, String alias)
+        public EntityNameReference(string type, string alias)
         {
             this.entityName = type;
             this.alias = alias;
@@ -22,7 +22,7 @@
          * 
          * @return The alias, the "p" in "Product as p" 
          */
-        public String Alias
+        public string Alias
         {
             get { return alias; }
         }
@@ -31,12 +31,12 @@
          * 
          * @return the entityname, the "Product" in "Product as b"
          */
-        public String EntityName
+        public string EntityName
         {
             get { return entityName; }
         }
 
-        public String ToString()
+        public string ToString()
         {
             return alias + ":" + entityName;
         }
Index: trunk/HqlIntellisense/HQLAnalyzer.cs
===================================================================
--- trunk/HqlIntellisense/HQLAnalyzer.cs	(revision 34)
+++ trunk/HqlIntellisense/HQLAnalyzer.cs	(working copy)
@@ -12,7 +12,7 @@
     {
 
 	    /** Defines the HQL keywords. Based on hql.g antlr grammer in 2005 ;) */
-        private static String[] hqlKeywords = { "between", "class", "delete",
+        private static string[] hqlKeywords = { "between", "class", "delete",
 			    "desc", "distinct", "elements", "escape", "exists", "false",
 			    "fetch", "from", "full", "group", "having", "in", "indices",
 			    "inner", "insert", "into", "is", "join", "left", "like", "new",
@@ -36,7 +36,7 @@
 	     * Maybe sShould try and do this dynamically based on dialect or
 	     * sqlfunctionregistry
 	     */
-        private static String[] builtInFunctions = {
+        private static string[] builtInFunctions = {
 			    // standard sql92 functions
 			    "substring", "locate", "trim", "length", "bit_length", "coalesce",
 			    "nullif", "abs", "mod", "sqrt",
@@ -254,7 +254,7 @@
         
         /** Returns reference name found from position and backwards in the array.
          **/
-        public static String GetEntityNamePrefix(char[] chars, int position)
+        public static string GetEntityNamePrefix(char[] chars, int position)
         {
             StringBuilder buff = new StringBuilder();
             for (int i = position - 1; i >= 0; i--) {
@@ -299,7 +299,7 @@
                 return tokenIds[i];
             }
 
-            public String GetTokenText(int i) 
+            public string GetTokenText(int i) 
             {
                 return  tokenText[i];
             }
@@ -422,11 +422,11 @@
         }
 
         
-        internal static String[] GetHQLKeywords() {
+        internal static string[] GetHQLKeywords() {
             return hqlKeywords;
         }
         
-        internal static String[] GetHQLFunctionNames() {
+        internal static string[] GetHQLFunctionNames() {
             return builtInFunctions;
         }
         
Index: trunk/HqlIntellisense/HQLCodeAssist.cs
===================================================================
--- trunk/HqlIntellisense/HQLCodeAssist.cs	(revision 34)
+++ trunk/HqlIntellisense/HQLCodeAssist.cs	(working copy)
@@ -26,11 +26,11 @@
 		    completion = new ConfigurationCompletion(configuration);
 	    }
 
-	    public void CodeComplete(String query, int position, IHQLCompletionRequestor collector) 
+	    public void CodeComplete(string query, int position, IHQLCompletionRequestor collector) 
         {
     		
 		    int prefixStart = FindNearestWhiteSpace(query, position);
-		    String prefix = query.Substring( prefixStart, position-prefixStart );
+		    string prefix = query.Substring( prefixStart, position-prefixStart );
     		
 		    bool showEntityNames;
 		    try 
@@ -44,7 +44,7 @@
 				        completion.GetMatchingImports( prefix, position, collector );				
 			        } else
                     {
-				        collector.completionFailure("Configuration not available nor open");
+				        collector.CompletionFailure("Configuration not available nor open");
 			        }
 		        } 
                 else 
@@ -56,21 +56,26 @@
                         // It's a simple path, not a dot separated one (find aliases that matches)
             	        foreach (EntityNameReference qt in visible)
                         {
-					        String alias = qt.Alias;
+					        string alias = qt.Alias;
                             if (alias.StartsWith(prefix))
                             {
-                    		        HQLCompletionProposal completionProposal = new HQLCompletionProposal(HQLCompletionProposal.ALIAS_REF, position);
-							        completionProposal.SetCompletion( alias.Substring( prefix.Length ) );
-                    		        completionProposal.SetReplaceStart( position );
-                    		        completionProposal.SetReplaceEnd( position+0 );
-                    		        completionProposal.SetSimpleName( alias );
-                    		        completionProposal.ShortEntityName =  qt.EntityName;
-                    		        if(HasConfiguration())
-                                    {
-                    			        String importedName = (String) GetConfiguration().Imports[ qt.EntityName ];
-                    			        completionProposal.EntityName =  importedName;
-                    		        }
-                    		        collector.accept( completionProposal );
+                    		        var completionProposal = new HQLCompletionProposal(CompletionKind.AliasRef, position)
+                    		                                 	{
+                    		                                 		Completion = alias.Substring(prefix.Length),
+                    		                                 		ReplaceStart = position,
+                    		                                 		ReplaceEnd = position + 0,
+                    		                                 		SimpleName = alias,
+                    		                                 		ShortEntityName = qt.EntityName
+                    		                                 	};
+                            	if(HasConfiguration())
+                                {
+                                	string importedName;
+									if(GetConfiguration().Imports.TryGetValue(qt.EntityName, out importedName))
+                                	{
+										completionProposal.EntityName =  importedName;
+                                	}
+                    		    }
+                    		    collector.Accept( completionProposal );
                             }                                        
                         }
                     } 
@@ -78,13 +83,13 @@
                     {
             	        if(HasConfiguration())
                         {        			
-            		        String path = CompletionHelper.getCanonicalPath(visible, prefix.Substring(0, dotIndex));
-            		        String propertyPrefix = prefix.Substring(dotIndex + 1);
+            		        string path = CompletionHelper.getCanonicalPath(visible, prefix.Substring(0, dotIndex));
+            		        string propertyPrefix = prefix.Substring(dotIndex + 1);
             		        completion.GetMatchingProperties( path, propertyPrefix, position, collector );
             	        }
                         else
                         {
-            		        collector.completionFailure("Configuration not available nor open");
+            		        collector.CompletionFailure("Configuration not available nor open");
             	        }
                     }
                     completion.GetMatchingFunctions( prefix, position, collector );
@@ -92,7 +97,7 @@
 		        }
 		    } catch(SimpleLexerException sle)
             {
-			    collector.completionFailure( "Syntax error: " + sle.Message );
+			    collector.CompletionFailure( "Syntax error: " + sle.Message );
 		    }
 	    }
     	
Index: trunk/HqlIntellisense/HQLCompletionProposal.cs
===================================================================
--- trunk/HqlIntellisense/HQLCompletionProposal.cs	(revision 34)
+++ trunk/HqlIntellisense/HQLCompletionProposal.cs	(working copy)
@@ -3,187 +3,113 @@
 // www.felicepollano.com
 
 using System;
-using NHibernate.Mapping;
 using System.Text;
+using HqlIntellisense.ConfigurationAbstraction;
+
 namespace HqlIntellisense
 {
+	public enum CompletionKind
+	{
+		EntityName = 1,
+		Property = 2,
+		KeyWord = 3,
+		Function = 4,
+		AliasRef = 5 // ref to an alias name, e.g. "bar" in "from Bar as bar where b|"
+	}
 
+	public class HQLCompletionProposal
+	{
+		public HQLCompletionProposal(CompletionKind kind, int cursorPosition)
+		{
+			EntityName = null;
+			ShortEntityName = null;
+			PropertyName = null;
+			CompletionKind = kind;
+			CompletionLocation = cursorPosition;
+		}
 
-    public class HQLCompletionProposal 
-    {
-    	
-	    static char[] NO_CHAR = new char[0];
-    	
-	    public const  int ENTITY_NAME = 1;
-        public const int PROPERTY = 2;
-        public const int KEYWORD = 3;
-        public const int FUNCTION = 4;
-        public const int ALIAS_REF = 5; // ref to an alias name, e.g. "bar" in "from Bar as bar where b|"
+		/// <summary>
+		/// The actual completion. 
+		/// </summary>
+		public string Completion { get; set; }
 
-        protected const int FIRST_KIND = ENTITY_NAME;
-        protected const int LAST_KIND = ALIAS_REF;
-    	
-	    /**
-	     * kind of completion request.
-	     */
-	    private int completionKind;
-    	
-	    /**
-	     * original cursorposition in the query
-	     */
-	    private int completionLocation;
-    	
-	    /**
-	     * The actual completion. 
-	     */
-	    private String completion = "";
-    	
-	    private int replaceStart = 0;	
-	    private int replaceEnd = 0;
-    	
-	    /**
-	     * Relevance rating
-	     */
-	    private int relevance = 1;
+		/// <summary>
+		/// kind of completion request
+		/// </summary>
+		public CompletionKind CompletionKind { get; set; }
 
-	    /** The default name for the entityname, keyword, property etc. */
-	    private String simpleName = "";
-    	
-	    /** The full related entity name, the resolved shortEntityName. Can be null */
-	    private String entityName = null;
-    	
-	    /** 
-	     * A short entity name. e.g. the imported name. 
-	     * e.g. "Product" instead of "org.hibernate.model.Product" 
-	     * (note: a imported name can also be the long version) 
-	     **/
-	    private String shortEntityName = null;
-    	
-	    /**
-	     * The propertyName, can be null.  
-	     */
-	    private String propertyName = null;
+		/// <summary>
+		/// original cursorposition in the query
+		/// </summary>
+		public int CompletionLocation { get; set; }
 
-	    /**
-	     * The underlying property. Can be null.
-	     */
-	    private Property property;
-    	
-	    public String GetCompletion() {
-		    return completion;
-	    }
+		/// <summary>
+		/// Relevance rating
+		/// </summary>
+		public int Relevance { get; set; }
 
-	    public void SetCompletion(String completion) {
-		    this.completion = completion;
-	    }
+		public int ReplaceEnd { get; set; }
+		public int ReplaceStart { get; set; }
 
-	    public int GetCompletionKind() {
-		    return completionKind;
-	    }
+		public string SimpleName { get; set; }
 
-	    public void SetCompletionKind(int completionKind) {
-		    this.completionKind = completionKind;
-	    }
+		/// <summary>
+		/// The full related entity name, the resolved shortEntityName. Can be null 
+		/// </summary>
+		public string EntityName { get; set; }
 
-	    public int GetCompletionLocation() {
-		    return completionLocation;
-	    }
+		/// <summary>
+		/// A short entity name. e.g. the imported name. 
+		/// e.g. "Product" instead of "org.hibernate.model.Product" 
+		/// (note: a imported name can also be the long version) 
+		/// </summary>
+		public string ShortEntityName { get; set; }
 
-	    public void SetCompletionLocation(int completionLocation) {
-		    this.completionLocation = completionLocation;
-	    }
+		/// <summary>
+		/// The propertyName, can be null.  
+		/// </summary>
+		public string PropertyName { get; set; }
 
-	    public int GetRelevance() {
-		    return relevance;
-	    }
+		/// <summary>
+		/// The underlying property. Can be null.
+		/// </summary>
+		public IPersistentProperty Property { get; set; }
 
-	    public void SetRelevance(int relevance) {
-		    this.relevance = relevance;
-	    }
-
-	    public int GetReplaceEnd() {
-		    return replaceEnd;
-	    }
-
-	    public void SetReplaceEnd(int replaceEnd) {
-		    this.replaceEnd = replaceEnd;
-	    }
-
-	    public int GetReplaceStart() {
-		    return replaceStart;
-	    }
-
-	    public void SetReplaceStart(int replaceStart) {
-		    this.replaceStart = replaceStart;
-	    }
-    	
-	    public HQLCompletionProposal(int kind, int cursorPosition) {
-		    this.completionKind = kind;
-		    this.completionLocation = cursorPosition; 
-	    }
-    		
-	    public String GetSimpleName() {
-		    return simpleName;
-	    }
-
-	    public void SetSimpleName(String simpleName) {
-		    this.simpleName = simpleName;
-	    }
-
-	    public override String ToString() 
-        {
-		    StringBuilder buffer = new StringBuilder();
-		    buffer.Append('[');
-		    switch(this.completionKind)
-            {
-			    case ENTITY_NAME :
-				    buffer.Append("ENTITY_NAME"); 
-				    break;
-			    case PROPERTY:
-				    buffer.Append("PROPERTY");
-				    break;
-			    case KEYWORD:
-				    buffer.Append("KEYWORD");
-				    break;
-			    default :
-				    buffer.Append("<Unknown type>");
-				    break;
-    				
-		    }
-		    buffer.Append("]{completion:"); //$NON-NLS-1$
-		    if (this.completion != null) buffer.Append(this.completion);
-		    buffer.Append(", simpleName:"); //$NON-NLS-1$
-		    if (this.simpleName != null) buffer.Append(this.simpleName);
-		    buffer.Append(", ["); //$NON-NLS-1$
-		    buffer.Append(this.replaceStart);
-		    buffer.Append(',');
-		    buffer.Append(this.replaceEnd);
-		    buffer.Append("], relevance="); //$NON-NLS-1$
-		    buffer.Append(this.relevance);
-		    buffer.Append('}');
-		    return buffer.ToString();
-	    }
-
-	    public String EntityName 
-        {
-            get { return entityName; }
-            set { entityName = value; }
-	    }
-        public String ShortEntityName
-        {
-            get { return shortEntityName; }
-            set { shortEntityName = value; }
-        }
-        public String PropertyName
-        {
-            get { return propertyName; }
-            set { propertyName = value; }
-        }
-
-        public Property Property
-        {
-            get { return property; }
-            set { property = value; }
-        }
-    }
+		/// <summary>
+		/// The default name for the entityname, keyword, property etc.
+		/// </summary>
+		/// <returns></returns>
+		public override string ToString()
+		{
+			var buffer = new StringBuilder();
+			buffer.Append('[');
+			switch (CompletionKind)
+			{
+				case CompletionKind.EntityName:
+					buffer.Append("ENTITY_NAME");
+					break;
+				case CompletionKind.Property:
+					buffer.Append("PROPERTY");
+					break;
+				case CompletionKind.KeyWord:
+					buffer.Append("KEYWORD");
+					break;
+				default:
+					buffer.Append("<Unknown type>");
+					break;
+			}
+			buffer.Append("]{completion:"); //$NON-NLS-1$
+			if (Completion != null) buffer.Append(Completion);
+			buffer.Append(", simpleName:"); //$NON-NLS-1$
+			if (SimpleName != null) buffer.Append(SimpleName);
+			buffer.Append(", ["); //$NON-NLS-1$
+			buffer.Append(ReplaceStart);
+			buffer.Append(',');
+			buffer.Append(ReplaceEnd);
+			buffer.Append("], relevance="); //$NON-NLS-1$
+			buffer.Append(Relevance);
+			buffer.Append('}');
+			return buffer.ToString();
+		}
+	}
 }
\ No newline at end of file
Index: trunk/HqlIntellisense/HqlIntellisense.csproj
===================================================================
--- trunk/HqlIntellisense/HqlIntellisense.csproj	(revision 34)
+++ trunk/HqlIntellisense/HqlIntellisense.csproj	(working copy)
@@ -12,6 +12,8 @@
     <AssemblyName>HqlIntellisense</AssemblyName>
     <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
+    <SignAssembly>true</SignAssembly>
+    <AssemblyOriginatorKeyFile>HqlIntellisense.snk</AssemblyOriginatorKeyFile>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
@@ -86,12 +88,22 @@
   </ItemGroup>
   <ItemGroup>
     <None Include="Grammar\Hql.g" />
+    <None Include="HqlIntellisense.snk" />
   </ItemGroup>
   <ItemGroup>
     <Compile Include="..\NHibernate.Tool.WorkBench.Core\Version.cs">
       <Link>Version.cs</Link>
     </Compile>
     <Compile Include="AntlrSimpleHQLLexer.cs" />
+    <Compile Include="ConfigurationAbstraction\PersistentIdentifierProperty.cs" />
+    <Compile Include="ConfigurationAbstraction\ConfigurationMapper.cs" />
+    <Compile Include="ConfigurationAbstraction\Interfaces.cs" />
+    <Compile Include="ConfigurationAbstraction\PersistentClassInformation.cs" />
+    <Compile Include="ConfigurationAbstraction\PersistentCollection.cs" />
+    <Compile Include="ConfigurationAbstraction\PersistentComponent.cs" />
+    <Compile Include="ConfigurationAbstraction\PersistentOneToMany.cs" />
+    <Compile Include="ConfigurationAbstraction\PersistentProperty.cs" />
+    <Compile Include="ConfigurationAbstraction\PersistentToOne.cs" />
     <Compile Include="IConfigurationDataProvider.cs" />
     <Compile Include="ISimpleHQLLexer.cs" />
     <Compile Include="CompletionHelper.cs" />
@@ -102,7 +114,7 @@
     <Compile Include="HQLCompletionProposal.cs" />
     <Compile Include="IHQLCodeAssist.cs" />
     <Compile Include="IHQLCompletionRequestor.cs" />
-    <Compile Include="NHConfigDataProvider.cs" />
+    <Compile Include="SimpleConfigurationProvider.cs" />
     <Compile Include="SimpleLexerException.cs" />
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
Index: trunk/HqlIntellisense/HqlIntellisense.snk
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: trunk\HqlIntellisense\HqlIntellisense.snk
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: trunk/HqlIntellisense/IConfigurationDataProvider.cs
===================================================================
--- trunk/HqlIntellisense/IConfigurationDataProvider.cs	(revision 34)
+++ trunk/HqlIntellisense/IConfigurationDataProvider.cs	(working copy)
@@ -4,8 +4,7 @@
 
 using System;
 using System.Collections.Generic;
-using System.Linq;
-using System.Text;
+using HqlIntellisense.ConfigurationAbstraction;
 
 namespace HqlIntellisense
 {
@@ -13,8 +12,8 @@
     {
         IDictionary<string, string> Imports { get; }
 
-        NHibernate.Mapping.PersistentClass GetClassMapping(string path);
+        IPersistentClassInformation GetClassMapping(string path);
 
-        NHibernate.Mapping.PersistentClass GetClassMapping(Type type);
+		IPersistentClassInformation GetClassMapping(Type type);
     }
 }
Index: trunk/HqlIntellisense/IHQLCodeAssist.cs
===================================================================
--- trunk/HqlIntellisense/IHQLCodeAssist.cs	(revision 34)
+++ trunk/HqlIntellisense/IHQLCodeAssist.cs	(working copy)
@@ -21,7 +21,7 @@
 		 * @param position the cursor position inside the query string  
 		 * @param requestor requestor on which the codeassist will call methods with information about proposals.
 		 */
-		void CodeComplete(String query, int position, IHQLCompletionRequestor requestor);	
+		void CodeComplete(string query, int position, IHQLCompletionRequestor requestor);	
 
 	}
 }
Index: trunk/HqlIntellisense/IHQLCompletionRequestor.cs
===================================================================
--- trunk/HqlIntellisense/IHQLCompletionRequestor.cs	(revision 34)
+++ trunk/HqlIntellisense/IHQLCompletionRequestor.cs	(working copy)
@@ -7,7 +7,7 @@
 {
     public interface IHQLCompletionRequestor
     {
-        bool accept(HQLCompletionProposal proposal);
-        void completionFailure(String errorMessage);
+        bool Accept(HQLCompletionProposal proposal);
+        void CompletionFailure(string errorMessage);
     }
 }
Index: trunk/HqlIntellisense/SimpleConfigurationProvider.cs
===================================================================
--- trunk/HqlIntellisense/SimpleConfigurationProvider.cs	(revision 34)
+++ trunk/HqlIntellisense/SimpleConfigurationProvider.cs	(working copy)
@@ -5,33 +5,36 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
-using System.Text;
-using NHibernate.Mapping;
-using NHibernate;
+using HqlIntellisense.ConfigurationAbstraction;
+using NHibernate.Cfg;
 
 namespace HqlIntellisense
 {
-    public class NHConfigDataProvider:IConfigurationDataProvider
+    public class SimpleConfigurationProvider : IConfigurationDataProvider
     {
-        NHibernate.Cfg.Configuration cfg;
-        public NHConfigDataProvider(NHibernate.Cfg.Configuration cfg)
+    	private readonly IEnumerable<IPersistentClassInformation> classes;
+
+
+    	public SimpleConfigurationProvider(Configuration cfg)
         {
-            this.cfg = cfg;
+			var mapper = new ConfigurationMapper(cfg);
+    		classes = mapper.GetClasses();
+    		Imports = cfg.Imports;
         }
 
-        #region IConfigurationDataProvider Members
-        public IDictionary<string, string> Imports
+    	#region IConfigurationDataProvider Members
+		public IDictionary<string, string> Imports
+		{
+			get; private set;
+		}
+        public IPersistentClassInformation GetClassMapping(string path)
         {
-            get { return cfg.Imports; }
+        	return classes.FirstOrDefault(c => c.ClassName == path);
         }
-        public NHibernate.Mapping.PersistentClass GetClassMapping(string path)
+		public IPersistentClassInformation GetClassMapping(Type type)
         {
-            return cfg.GetClassMapping(path);
+			throw new NotImplementedException();
         }
-        public NHibernate.Mapping.PersistentClass GetClassMapping(Type type)
-        {
-            return cfg.GetClassMapping(type);
-        }
         #endregion
     }
 }
Index: trunk/HqlIntellisense/SimpleLexerException.cs
===================================================================
--- trunk/HqlIntellisense/SimpleLexerException.cs	(revision 34)
+++ trunk/HqlIntellisense/SimpleLexerException.cs	(working copy)
@@ -15,13 +15,13 @@
 		
 	}
 
-	public SimpleLexerException(String message, Exception cause)
+	public SimpleLexerException(string message, Exception cause)
         :base( message, cause )
     {
 		
 	}
 
-	public SimpleLexerException(String message) 
+	public SimpleLexerException(string message) 
         :base(message)
     {
 		
Index: trunk/NHibernate.Tool.WorkBench/Project/ProjectPresenter.cs
===================================================================
--- trunk/NHibernate.Tool.WorkBench/Project/ProjectPresenter.cs	(revision 34)
+++ trunk/NHibernate.Tool.WorkBench/Project/ProjectPresenter.cs	(working copy)
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
+using HqlIntellisense.ConfigurationAbstraction;
 using NHibernate.Tool.WorkBench.Core.WireAttributes;
 using NHibernate.Tool.WorkBench.Core;
 using NHibernate.Tool.WorkBench.Core.Commands;
@@ -336,22 +337,22 @@
             }
         }
 
-        public NHibernate.Mapping.PersistentClass GetClassMapping(string path)
+        public IPersistentClassInformation GetClassMapping(string path)
         {
-            var rc = new RootClass();
-            foreach (string p in probe.GetProperties(path))
-            {
-                JavaScriptSerializer ser = new JavaScriptSerializer();
-                IDictionary<string,object> obj = ser.DeserializeObject(p) as IDictionary<string,object>;
-                var prop = new Property();
-                prop.Value = NHValueJSonHelper.JSonDeserialize(prop.GetType().Assembly, obj["Value"] as IDictionary<string,object>) as IValue;
-                prop.Name = obj["Name"] as string; 
-                rc.AddProperty( prop);
-            }
-            return rc;
+			var rc = new RootClass();
+			foreach (string p in probe.GetProperties(path))
+			{
+			    var ser = new JavaScriptSerializer();
+			    var obj = ser.DeserializeObject(p) as IDictionary<string,object>;
+			    var prop = new Property();
+			    prop.Value = NHValueJSonHelper.JSonDeserialize(prop.GetType().Assembly, obj["Value"] as IDictionary<string,object>) as IValue;
+			    prop.Name = obj["Name"] as string; 
+			    rc.AddProperty( prop);
+			}
+        	return ConfigurationMapper.MapClass(rc);
         }
 
-        public NHibernate.Mapping.PersistentClass GetClassMapping(System.Type type)
+		public IPersistentClassInformation GetClassMapping(System.Type type)
         {
             throw new NotImplementedException();
         }
Index: trunk/TestHqlIntellisense/BasicTests.cs
===================================================================
--- trunk/TestHqlIntellisense/BasicTests.cs	(revision 34)
+++ trunk/TestHqlIntellisense/BasicTests.cs	(working copy)
@@ -5,6 +5,7 @@
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
+using HqlIntellisense.ConfigurationAbstraction;
 using NUnit.Framework;
 using HqlIntellisense;
 using NHibernate.Cfg;
@@ -34,7 +35,7 @@
         {
             HQLCodeAssist assist = new HQLCodeAssist(null);
             assist.CodeComplete("from xxxxxx e where ", 20, this);
-            Assert.That(proposals.Any(q=>q.GetSimpleName()=="e"));
+            Assert.That(proposals.Any(q=>q.SimpleName=="e"));
         }
 
         [Test]
@@ -42,7 +43,7 @@
         {
             HQLCodeAssist assist = new HQLCodeAssist(null);
             assist.CodeComplete("from xxxxxx e where e.id in ( select id from other x where  )", 59, this);
-            Assert.That(proposals.Any(q => q.GetSimpleName() == "x"));
+            Assert.That(proposals.Any(q => q.SimpleName == "x"));
         }
         [Test]
         public void TestCompleteShouldEmitNothing()
@@ -56,16 +57,16 @@
         public void TestSelectPropertyCompletion()
         {
             Configuration cfg = CreateCfg();
-            HQLCodeAssist assist = new HQLCodeAssist( new NHConfigDataProvider(cfg));
-            assist.CodeComplete("select x. from myentity x", 9, this);
+            HQLCodeAssist assist = new HQLCodeAssist( new SimpleConfigurationProvider(cfg));
+            assist.CodeComplete("select x. from MyEntity x", 9, this);
             Assert.That(proposals.Count == 5);
         }
         [Test]
         public void TestSelectManyToOneCompletion()
         {
             Configuration cfg = CreateCfg();
-            HQLCodeAssist assist = new HQLCodeAssist( new NHConfigDataProvider(cfg));
-            assist.CodeComplete("select x.Referenced. from myentity x", 20, this);
+            HQLCodeAssist assist = new HQLCodeAssist( new SimpleConfigurationProvider(cfg));
+            assist.CodeComplete("select x.Referenced. from MyEntity x", 20, this);
             Assert.That(proposals.Count == 3);
         }
 
@@ -73,23 +74,23 @@
         public void TestWherePropertyCompletion()
         {
             Configuration cfg = CreateCfg();
-            HQLCodeAssist assist = new HQLCodeAssist( new NHConfigDataProvider(cfg));
-            assist.CodeComplete("from myentity x where x.", 24, this);
+            HQLCodeAssist assist = new HQLCodeAssist( new SimpleConfigurationProvider(cfg));
+            assist.CodeComplete("from MyEntity x where x.", 24, this);
             Assert.That(proposals.Count == 5);
         }
         [Test]
         public void TestWhereOnManyToOnePropertyCompletion()
         {
             Configuration cfg = CreateCfg();
-            HQLCodeAssist assist = new HQLCodeAssist( new NHConfigDataProvider(cfg));
-            assist.CodeComplete("from myentity x where x.Referenced.", 35, this);
+            HQLCodeAssist assist = new HQLCodeAssist( new SimpleConfigurationProvider(cfg));
+            assist.CodeComplete("from MyEntity x where x.Referenced.", 35, this);
             Assert.That(proposals.Count == 3);
         }
         [Test]
         public void TestEntitiesCompletion()
         {
             Configuration cfg = CreateCfg();
-            HQLCodeAssist assist = new HQLCodeAssist( new NHConfigDataProvider(cfg));
+            HQLCodeAssist assist = new HQLCodeAssist( new SimpleConfigurationProvider(cfg));
             assist.CodeComplete("from ", 5, this);
             Assert.That(proposals.Count == 4);
         }
@@ -97,10 +98,19 @@
         public void TestNestedPropertyCompletion()
         {
             Configuration cfg = CreateCfg();
-            HQLCodeAssist assist = new HQLCodeAssist( new NHConfigDataProvider(cfg));
-            assist.CodeComplete("from myentity x where x in ( select y. from referenced y)", 38, this);
+            HQLCodeAssist assist = new HQLCodeAssist( new SimpleConfigurationProvider(cfg));
+			assist.CodeComplete("from MyEntity x where x in ( select y. from Referenced y)", 38, this);
             Assert.That(proposals.Count == 3);
         }
+
+		[Test]
+		public void WhenImportsDoesNotContainEntityNameThenNotThrow()
+		{
+			HQLCodeAssist assist = new HQLCodeAssist(new EmptyConfiguratorProvider());
+			assist.CodeComplete("from xxxxxx e where ", 20, this);
+			Assert.That(proposals.Any(q => q.SimpleName == "e"));
+		}
+
         public static Configuration CreateCfg()
         {
             Configuration cfg = new Configuration();
@@ -109,18 +119,35 @@
             cfg.CreateMappings(new NHibernate.Dialect.GenericDialect());
             return cfg;
         }
+		
+		private class EmptyConfiguratorProvider : IConfigurationDataProvider
+		{
+			public IDictionary<string, string> Imports
+			{
+				get { return new Dictionary<string, string>(); }
+			}
 
+			public IPersistentClassInformation GetClassMapping(string path)
+			{
+				return null;
+			}
 
+			public IPersistentClassInformation GetClassMapping(Type type)
+			{
+				return null;
+			}
+		}
+
         #region IHQLCompletionRequestor Members
 
-        public bool accept(HQLCompletionProposal proposal)
+        public bool Accept(HQLCompletionProposal proposal)
         {
             Console.WriteLine(proposal.ToString());
             proposals.Add(proposal);
             return false;
         }
 
-        public void completionFailure(string errorMessage)
+        public void CompletionFailure(string errorMessage)
         {
             
         }
Index: trunk/TestHqlIntellisense/Referenced.hbm.xml
===================================================================
--- trunk/TestHqlIntellisense/Referenced.hbm.xml	(revision 0)
+++ trunk/TestHqlIntellisense/Referenced.hbm.xml	(revision 0)
@@ -0,0 +1,12 @@
+﻿<?xml version="1.0" encoding="utf-8" ?>
+<hibernate-mapping xmlns="urn:nhibernate-mapping-2.2" assembly="TestHqlIntellisense" namespace="TestHqlIntellisense">
+  <class name="Referenced" lazy="false">
+    <id type="Int32">
+      <generator class="native" />
+    </id>
+    <property name="R1" type="String"/>
+    <property name="R2" type="String"/>
+    <property name="R3" type="String"/>
+    
+  </class>
+</hibernate-mapping>
\ No newline at end of file
Index: trunk/TestHqlIntellisense/TestHqlIntellisense.csproj
===================================================================
--- trunk/TestHqlIntellisense/TestHqlIntellisense.csproj	(revision 34)
+++ trunk/TestHqlIntellisense/TestHqlIntellisense.csproj	(working copy)
@@ -91,7 +91,7 @@
     <EmbeddedResource Include="Entity.hbm.xml" />
   </ItemGroup>
   <ItemGroup>
-    <EmbeddedResource Include="Reefrenced.hbm.xml" />
+    <EmbeddedResource Include="Referenced.hbm.xml" />
   </ItemGroup>
   <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
